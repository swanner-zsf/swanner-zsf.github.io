{"pages":[],"posts":[{"title":"前端调用 face++ API实现微信小程序身份证识别","text":"小程序拍照并本地保存拍摄身份证得到照片，将照片路径保存至data中： 12345&lt;!-- camera.wxml --&gt;&lt;camera device-position=\"back\" flash=\"off\" binderror=\"error\" style=\"width: 100%; height: 300px;\"&gt;&lt;/camera&gt;&lt;button type=\"primary\" bindtap=\"takePhoto\"&gt;拍照&lt;/button&gt;&lt;view&gt;预览&lt;/view&gt;&lt;image mode=\"widthFix\" src=\"{{src}}\"&gt;&lt;/image&gt; 1234567891011121314151617// camera.jsPage({ takePhoto() { const ctx = wx.createCameraContext() ctx.takePhoto({ quality: 'high', success: (res) =&gt; { this.setData({ src: res.tempImagePath }) } }) }, error(e) { console.log(e.detail) }}) 照片转base64编码格式通过微信小程序文件管理器wx.getFileSystemManager获得照片路径，通过encoding将它转为base64编码格式。 12345678let that = this;wx.getFileSystemManager().readFile({ filePath: this.data.src, encoding: 'base64', success: res =&gt; { let _img_base64 = 'data:image/png;base64,' + res.data; }}); 调用face++ API通过wx.request向face++请求回数据请求参数(必选）: api_key: “xxx” api_secret: “xxx” image_url / image_file / image_base64 数据返回成功后，将数据保存123456789101112131415161718wx.request({ url: 'https://api-cn.faceplusplus.com/cardpp/v1/ocridcard', data: { api_key: '', api_secret: '', image_base64: _img_base64 }, method: \"POST\", header: { 'content-type': 'application/x-www-form-urlencoded' // 默认值 }, success: function(res) { that.setData({ identity : res.data.cards[0] }); console.log(that.data.identity); } })","link":"/2019/09/14/face++/"},{"title":"Markdown 基本语法","text":"换行在行后空两格回车，自动换行。 表格表格内文本位置默认居左，居右写法 —:居中写法 :—: 1234567大标题1|大标题2|大标题3 ---|---|--- 内容1|内容2|内容3 内容1|内容2|内容3 列表列表形式需与上文空行；符号 - + * 和内容之间需加空格。 无序列表: 123- 列表内容+ 列表内容* 列表内容 有序列表：任意数字加点、加空格、加内容 1231. 列表内容2. 列表内容3. 列表内容 下划线在markdown中使用下划线 “_” ,需要在前加反斜杠 “ \\ “ 表示。 超链接[链接名](链接地址)","link":"/2019/09/14/markdown-notes/"},{"title":"Vue.js入门","text":"Vue.js1. Vue.js知识点1.1 $mount() &amp; el$mount()为手动挂载，在项目中可用于延时挂载，之后要手动挂载上。new Vue时，el和$mount并没有本质上的不同。 未答疑： 知识点 问题 相关链接 watch?computed link1 event对象 $event $event.target.value link2 2. iview2.1 inputinput数据双向绑定: 1v-model=\"value\" input type=”radio” name:name 属性可设置或返回单选按钮的名称。在多个单选按钮存在情况下，设置相同name，可实现单选效果。 input 遍历绑定 123456789101112131415&lt;template&gt; &lt;label v-for=\"item in arr\" :for=\"item\"&gt; &lt;input :value=\"item\"/&gt;{{ item }} &lt;/label&gt;&lt;/template&gt;&lt;script&gt; export default { data() { return { arr: [] } } }&lt;/script&gt; input 修饰符 .lazy 在失去焦点的时候才更新，而不是实时更新 1&lt;input v-model.lazy=\"\"/&gt; .number 自动将用户的输入值转为 Number 类型 1&lt;input v-model.number=\"\"/&gt; .trim 自动过滤用户输入的首尾空格 1&lt;input v-model.trim=\"\"/&gt; 2.2 监听键盘事件1&lt;i-input v-model=\"input\" @keyup.enter.native=\"\"&gt;&lt;/i-input&gt; 绑定事件多一个.native修饰符，是因为iview封装了个div在input标签外面，把原来的事件隐藏了，所以如果不加.native的话，按键不会生效。 2.3 响应式的数组方法响应式： push() pop() shift()… 非响应式（html页面不会响应）： this.array[0] = “a” (通过数组索引的形式改变数组元素) 2.4 扩展运算符(…)对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中 12let a = { a: 1, b: 2 }let b = { ...a } //{ a: 1, b: 2 } 2.5 css: scoped 与 module2.5.1 scoped12&lt;style scoped&gt;&lt;/style&gt; scoped作用:阻止上层的css样式传递到下层，限制当前css作用域，使其只对当前组件生效。深度作用:如果希望scoped中的某个样式能够作用的更深，影响到子组件，可以使用&gt;&gt;&gt;操作符 123456&lt;style scoped&gt;.content &gt;&gt;&gt; .title-wrap { font-size: 20px; color: red;}&lt;/style&gt; 注意看我将style中的lang=”scss”去掉了，因为加了预处理器后无法正确解析&gt;&gt;&gt;，这种情况可以使用/deep/代替，本质是&gt;&gt;&gt;的别名 12345678910&lt;style lang=\"scss\" scoped&gt;.content { /deep/ { .title-wrap { font-size: 20px; color: red; } }}&lt;/style&gt; 2.5.2 module12&lt;style lang=\"scss\" module&gt;&lt;/style&gt; module作用: 快速定位 灵活传递到任意子组件 它在布局中的引用，都需要添加前缀$style,因为通过module作用的style都被保存到$style对象中。 2.6 动态绑定class:class我们可以把:class直接赋值一个对象: 12345678&lt;div class=\"mySelf\" :class=\"classObject\"&gt;&lt;/div&gt;data:{ classObject:{ 'class-a':true, 'class-b':false }} 根据条件切换列表的class，可以用三元表达式: 1&lt;div :class=\"[classA,isB?classB:'']\"&gt;&lt;/div&gt; 根据路由路径绑定内联样式: 12&lt;div class=\"mySelf\" :class=\"{ on : '/' === $route.path }\"&gt;&lt;/div&gt;// $route =&gt; 路由信息对象 2.7 disabled控制元素是否可用 1&lt;button :disable=\"true/false\"&gt;{{ }}&lt;/button&gt; 2.8 filter过滤器123456789&lt;div&gt;{{ msg | change }}&lt;/div&gt;&lt;script&gt;filters: { change (value) { return value + '{STRING}'; }}&lt;/script&gt; 3. Vuex3.1 Vuex介绍Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，将我们需要共享的data，使用vuex进行统一集中式的管理。 3.2 vue实例全局引入store对象Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： 12345var vm = new Vue({ el: '#app', store, render: c =&gt; c(app)}) 3.3 new Vuex.Store1234567891011121314151617181920export default new Vuex.Store({ state: { count: 123, todos: [], }, getters: { doneTodos: state =&gt; { //传入state参数 state.todos.length, } }, mutations: { increment (state) { //传入state参数 state.count++ }, actions: { increment (context) { //Action函数接受一个与 store 实例具有相同方法和属性的 context 对象 context.commit('increment') } }}) 基本对象 使用方法 1 state 存储状态(变量) 2 getters 对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $store.getters.fun() 3 mutations 修改状态，同步操作,在组件中使用$store.commit(‘’,params) 4 actions 异步操作,在组件中使用是$store.dispath(‘’) 注意: Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Action方法调用mutation方法(简化代码): 12345678910mutations: { increment (state) { //传入state参数 state.count++ },actions: { increment ({ commit }) { //通过commit提交一个 mutation方法 commit('increment') //调用mutations内的方法 }} 3.4 将store中的对象传入子组件 方法1 1&lt;div&gt;{{ this.$store.state.count }}&lt;/div&gt; 方法2 1234567import { mapState, mapGetters, mapMutations, mapActions } from 'vuex'export default { computed: mapState({ count: state =&gt; state.count //映射 this.count为store.state.count }),} 方法3 1234567891011import { mapState, mapGetters, mapMutations, mapActions } from 'vuex'export default { computed: { ...mapState([\"count\"]) //...对象展开运算符 }, methods: { ...mapMutations(), ...mapActions(), } ,} 传入store下home模块下的state数据 12345import { mapState } from 'vuex'computed: { ...mapState({\"area\": state =&gt; state.home.area})},","link":"/2019/09/21/Vue-js入门/"},{"title":"微信小程序前端开发","text":"事件绑定冒泡事件 点击事件：tap 长按事件：longtap 触摸事件：touchstart / touchend / touchmove / touchcancel bind绑定与catch绑定区别 bind不阻止事件向上冒泡 catch阻止事件向上冒泡","link":"/2019/09/15/微信小程序/"},{"title":"微信小程序form提交.md.","text":"","link":"/2019/09/16/微信小程序form提交/"},{"title":"node.js入门","text":"1.node.js搭建http服务1.1 hello word demo123456var http = require(\"http\");http.createServer((req, res) =&gt; { console,log(req.url); res.write(\"&lt;html&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;\")}).listen(3000, console.log(\"server running...\")) 1.2 GET &amp;&amp; POST123456789101112131415161718var http = require(\"http\");var url = require(\"url\");http.createServer((req, res) =&gt; { console.log(req.method); if(req.method === \"GET\") { var params = url.parse(req.url, true, true) res.end(JSON.stringify(params)); }else if(req.method === \"POST\") { var data_str = \"\"; req.on(\"data\", (chunk) =&gt; { data_str += chunk }); res.end(data_str); }}).listen(3000, () =&gt; { console.log(\"srever running...\")}) node.js中url.parse() 方法使用说明: 将一个url字符串转换成对象并返回 语法 1url.parse(urlStr, [parseQueryString], [slashesDenoteHost]) 接收参数 参数 含义 1 urlStr url字符串 2 parseQueryString 为true时将使用查询模块分析查询字符串，默认为false 3 slashesDenoteHost 默认为false，//foo/bar 形式的字符串将被解释成 { pathname: ‘//foo/bar’ },如果设置成true，//foo/bar 形式的字符串将被解释成 { host: ‘foo’, pathname: ‘/bar’ } 2. Express搭建http服务2.1 Express安装12$ cnpm install express --save$ cnpm install 2.2 Express框架实例1234567891011121314151617181920212223242526272829303132var express = require(\"express\");var app = express();app.use(express.json());app.use(express.urlencoded());app.get(\"/\", (req, res) =&gt; { res.send(\"hello world\")})function RetObj(statusCode, msg) { var ret = new Object; ret.statusCode = statusCode; ret.msg = msg, return ret;}app.post(\"/\", (req, res) =&gt; { //检查key值是否存在 if(!(\"\" in req.body)) { var ret = RetObj(4000, \"fail\"); req.send(ret); }else{ var ret = RetObj(2000, \"success\"); req.send(ret); }})app.listen(3000, () =&gt; { console.log(\"express server running on 3000...\")})","link":"/2019/09/23/node-js入门/"},{"title":"JavaScript基础","text":"1. Array1.1 熟悉 toString() push() 数组末尾添加元素，并返回添加元素后的数组长度。 pop() 删除数组的最后一个元素，并返回该删除元素。 reverse() 用于颠倒排列数组元素，返回改变后的数组。 1.2 不熟悉 函数名称 用途 1 Array.isArray() 判断是否为数组,返回布尔值 2 valueOf() 数组的valueOf()方法返回数组本身 3 shift() 用于删除数组的第一个元素，并返回该元素 4 unshift() 在数组的第一个位置添加元素，并返回添加新元素后的数组长度 5 join() 以指定参数作为分隔符，将所有数组元素连接成为一个字符串返回 6 concat() 用于多个数组的合并 7 slice() 用于提取目标数组的一部分，返回一个新数组。第一个参数为起始位置，第二个参数为终止位置，如果省略第二个参数，则一直返回到数组最后一个元素 （重要应用：将类似数组的对象转为真正的数组 8 splice(start, count, addElement1, …) 第一个参数是删除的起始位置，第二个参数是被删除的个数，后面的参数表示要被插入数组的新元素。（如果只是单纯地插入元素，第二个参数可以设为0；如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组） 9 sort() 数值先被转成字符串再按字典排序; 自定义排序：传入一个函数作为参数 10 map() 将数组的所有成员依次传入参数函数 11 forEach() forEach()无法中断执行，总是会将所有成员遍历完。 12 filter() 过滤数组成员，返回新数组，filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组。filter方法还可以接受第二个参数，用来绑定参数函数内部的this变量。 13 some(), every() 接受一个函数作为参数，该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。 14 reduce(), reduceRight() 依次处理数组的每个成员，它的参数函数接受以下4个参数：1.累积变量，默认为数组的第一个成员 2.当前变量，默认为数组的第二个成员 3.当前位置（从0开始）4.原数组 15 indexOf(), lastIndexOf() 返回给定元素在数组中第一次和最后一次出现的位置， 如果没有出现则返回-1。 1.3 Array要点构造函数写法 new Array() 缺陷：不同的参数会导致行为不一致，因此不建议使用它生成新数组，直接使用数组字面量更好： 1var arr = [1, 2]; 判断对象类型： 1typeof 2. String2.1 String实例属性String.prototype.length 2.2 String实例方法 函数名称 使用方法 1 charAt() 返回指定位置的字符，可以用数组下标代替 2 concat() 连接两个字符串 3 slice() 从原数组取出字符串并返回 4 substring() 与slice()方法相似，不同之处：substring()会将负数的参数自动变成0；当第二个参数小于第一个参数，会自动互换位置。 5 substr() 与slice(),substring()相似，不同之处：如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 6 indexOf(), lastIndexOf() 可以接受第二个参数，表示从该位置向后（向前）匹配。 7 trim() 去除字符串两端的空格，返回一个新字符串，不改变原字符串 8 toLowerCase()/ toUpperCase() 全部转为小写/全部转为大写 9 match() 用于确定原字符串是否匹配某个子字符串，返回匹配的第一个字符串，没找到返回null;返回的数组还有index属性和input属性，分别表示匹配字符串开始的位置和原始字符串。 10 search(), replace() 基本等同于match(),返回值为匹配的第一个位置，没找到返回-1；replace() 一般情况下只替换第一个匹配。 11 split() 分割字符串，第二个参数限定返回数组的最大成员数。 12 localeCompare() 比较两个字符串：&lt;0,0,&gt;0 3. Math3.1 Math静态属性Math.E: 常数eMath.PI: 常数π 3.2 Math静态方法 函数名称 使用方法 1 Math.abs() 绝对值 2 Math.ceil() 向上取整 3 Math.floor() 向下取整 4 Math.max() 最大值 5 Math.min() 最小值 6 Math.round() 四舍五入 7 Math.random 随机值 4. Number4.1 Number静态属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。Number.NaN：表示非数值，指向NaN。Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324）。Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 4.2 Number实例方法 函数名称 使用方法 1 Number.prototype.toString() 用来将一个数值转为字符串形式 2 Number.prototype.toFixed() 将一个数转为指定位数的小数，然后返回这个小数对应的字符串 3 Number.prototype.toExponential() 将一个数转为科学计数法形式 4 Number.prototype.toPrecision() 将一个数转为指定位数的有效数字 jQuery 遍历方法$.each()$.each(array,function(index,value){})用于遍历数组或对象 $().each()$(‘selector’).each(function(index,value){…})用于遍历dom数组 array.forEach()arr.forEach(function(item,index,array){…})用于遍历数组forEach方法不会跳过null和undefined元素 5. || &amp;&amp; 运算符&amp;&amp;console.log( 5 &amp;&amp; 4 );//当结果为真时，返回第二个为真的值4console.log( 0 &amp;&amp; 4 );//当结果为假时，返回第一个为假的值0 ||console.log( 5 || 4 );//当结果为真时，返回第一个为真的值5console.log( 0 || 0 );//当结果为假时，返回第二个为假的值0console.log((3||2)&amp;&amp;(5||0));//5","link":"/2019/09/19/JavaScript基础/"},{"title":"进制","text":"1. 位运算符 位运算符 定义 1 &amp; 相同位的两个数字都为1，则为1；若有一个不为1，则为0。 2 | 相同位只要一个为1即为1。 3 ^ 某位不同则该位为1, 否则该位为0. 4 ~ 把内存中的0和1全部取反 5 &lt;&lt; a &lt;&lt; b就表示把a转为二进制后左移b位（在后面添b个0）, a shl b的值实际上就是a乘以2的b次方 6 &gt;&gt; a &gt;&gt; b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整） 1,1 与 &amp;用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。 1.2 or运算 |or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。相同位只要一个为1即为1。 1.3 xor运算 ^异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0. 1.4 not运算 ~not运算的定义是把内存中的0和1全部取反。使用not运算时要格外小心，你需要注意整数类型有没有符号。如果not的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用00到$FFFF依次表示的。 1.5 shl运算 &lt;&lt;a shl b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 shl 2 = 400。可以看出，a shl b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。 1.6 shr运算 &gt;&gt;和shl相似，a shr b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。 2. 单精度、双精度","link":"/2019/09/29/进制/"},{"title":"Node.js之request模块","text":"1. request介绍node中，http模块也可作为客户端使用（发送请求），第三方模块request对其使用方法进行了封装，操作更方便。 2. request安装1cnpm install request --save 3. request请求引入request 1const request = require('request') 3.1 GET123456// 发送Get请求// 第一个参数:请求的完整URL,包括参数// 第二个参数:请求结果回调函数,会传入3个参数,第一个错误,第二个响应对象,第三个请求数据request(url,function (error, response, data) { console.log(data)}); 3.2 POSTpost请求有3种方式，由请求头中的content-type决定，属于哪一种post请求: application/x-www-form-urlencoded application/json multipart/form-data 1.application/x-www-form-urlencoded 1234request.post({url:url, form:{key:'value'}}, function(error, response, body) { if (!error &amp;&amp; response.statusCode == 200) { }}) 2.application/json 123456789101112request({ url: url, method: \"POST\", json: true, headers: { \"content-type\": \"application/json\", }, body: JSON.stringify(requestData)}, function(error, response, body) { if (!error &amp;&amp; response.statusCode == 200) { }}); 3.multipart/form-data 123456789101112var formData = { // Pass a simple key-value pair my_field: 'my_value', // Pass data via Buffers my_buffer: new Buffer([1, 2, 3]), // Pass data via Streams my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),};request.post({url:url, formData: formData}, function (error, response, body) { if (!error &amp;&amp; response.statusCode == 200) { }})","link":"/2019/09/28/Node-js之request模块/"},{"title":"Node.js之fs模块","text":"1. fs介绍node.js内置的fs模块就是文件系统模块，负责读写文件。和所有其他JS模块不同的是，fs模块同时提供了异步和同步的方法。 2. fs用法详解2.1 fs引入 1const fs = require('fs') 2.2 fs功能进行网络爬虫的时候，有时我们需要保存图片、js、css等文件，request支持文件流. 12request('https://www.baidu.com/img/bd_logo1.png').pipe(fs.createWriteStream('a.png'))//抓取百度logo并保存到本地 也可以将文件传给PUT或POST请求，用于文件上传。未提供header的情况下，会检测文件后缀名，在PUT请求中设置相应的content-type。 12fs.createReadStream('pic.jpg').pipe(request.put('http://veb.com/upload'))//读取流pipe上传","link":"/2019/09/28/Node-js之fs模块/"},{"title":"express框架连接数据库","text":"1. ORM对象关系映射（Object Relational Mapping）：ORM 技术是在对象和数据库之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化。 1.1 SequelizeSequelize 是一款比较流行的 ORM 框架 1.2 Sequelize安装1$ cnpm install sequelize --save 2.通过scquelize与数据库建立连接2.1 创建sequelize实例要连接到数据库，必须创建一个Sequelize实例。这可以通过将连接参数分别传递到Sequelize构造函数或通过传递单个连接URI来完成： 123const Sequelize = require('sequelize');const sequelize = new Sequelize('mariadb://user:pass@localhost:3306/dbname'); 2.2 测试连接12345678sequelize .authenticate() .then(() =&gt; { console.log('Connection has been established successfully.'); }) .catch(err =&gt; { console.error('Unable to connect to the database:', err); }); 通过 1module.exports = sequelize 将sequelize模块导出。 2.3 建模表格12345678910111213141516171819202122const Sequelize = require('sequelize');const sequelize = require('../db'); const Model = Sequelize.Model;class User extends Model {}//class User 继承 Model {}User.init({ // User初始化 username: { type: Sequelize.STRING, }, password: { type: Sequelize.STRING }}, { sequelize, createdAt: false, updatedAt: false, tableName: 'zhuzhu'});module.exports = User; 2.4 查询1234567891011121314151617181920var express = require('express');var router = express.Router();let User = require('../model/User');let _user = null;/* GET home page. */router.get('/', function(req, res, next) { User.findAll().then(users =&gt; { _us = JSON.stringify(users, null, 4) //JSON.stringify() //第一个参数：被转换的值 //第二个参数：被转换的字符串属性 //第三个参数：如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 console.log(\"All users:\", JSON.stringify(_user, null, 4)); }); res.render('index', { title: _user });});module.exports = router;","link":"/2019/09/27/express框架连接数据库/"},{"title":"flask","text":"flask 全局变量gflask-session组件lask_caching组件","link":"/2019/10/12/flask/"},{"title":"Vue.js-基础","text":"父子组件通信props父级组件中引用子组件，并将自己data下面的数据传给子组件，子组件需要通过props接收父级传来的数据。 父组件: 123456789101112131415161718&lt;template&gt; &lt;son :sondata=\"msg\"/&gt; //通过自定义绑定绑定父组件data中的数据&lt;/template&gt;&lt;script&gt;import son from \"\" //引入子组件 export default { components: { son: son //子组件注册，命名son } data () { return { msg: \"hello\" } } }&lt;/script&gt; 子组件: 1234567891011121314151617181920212223242526&lt;template&gt; &lt;h1&gt;{{ sondata }}&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default { props: [\"sondata\"] //props使用数组形式传值 props: { sondata: String } //props使用对象形式，数据类型验证才传值 props: { sondata: { type: String, default: \"***\" //默认值 required: true //required为true时，该值为必传值，否则报错。 } } data () { return { } } }&lt;/script&gt; $emit子组件通过$emit的参数向父级传递数据。 父组件: 123456789101112131415161718192021&lt;template&gt; &lt;son @func=\"myclick\"/&gt; //通过自定义绑定监听子组件&lt;/template&gt;&lt;script&gt;import son from \"\" export default { data () { datafromson: null }, methods: { myclick (argument) { console.log(\"我是父组件事件\" + argument) //接收到子组件参数 this.datafromson = argument //通过data赋值将参数保存至父组件data中 } } }&lt;/script&gt; 子组件: 123456789101112131415&lt;template&gt; &lt;button @click=\"myclick\"&gt;按钮&lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default { data() { }, methods: { myclick() { this.$emit(\"func\",argument) //子组件通过$emit触发通过函数参数向父组件传参 } } }&lt;/script&gt; $children父组件: 12345678910111213&lt;div&gt; &lt;button @click=\"myclick\"&gt;&lt;/button&gt; &lt;children&gt;&lt;/children&gt; &lt;children&gt;&lt;/children&gt;&lt;/div&gt;&lt;script&gt; methods: { myclick() { console.log(this.$children[0]) } }&lt;/script&gt; $children获取的是子组件的数组 通过索引找到对应的子组件的实例。 $refs父组件: 12345678910111213&lt;div&gt; &lt;button @click=\"myclick\"&gt;&lt;/button&gt; &lt;children ref=\"{NAME}\"&gt;&lt;/children&gt; &lt;children ref=\"{NAME}\"&gt;&lt;/children&gt;&lt;/div&gt;&lt;script&gt; methods: { myclick() { console.log(this.$refs.{NAME}) } }&lt;/script&gt; ref 作用在组件上指向的是子组件的实例,实例上的方法都可以调用 $parent子组件: 1234567891011&lt;div&gt; &lt;button @click=\"myclick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script&gt; methods: { myclick: { console.log(this.$parent) } }&lt;/script&gt; 子组件通过$parent获取父组件的数据和方法。 $root子组件: 1234567891011&lt;div&gt; &lt;button @click=\"myclick\"&gt;按钮&lt;/button&gt;&lt;/div&gt;&lt;script&gt; methods: { myclick: { console.log(this.$root) } }&lt;/script&gt; 子组件通过$root获取根父组件的数据和方法。 vue中央事件总线eventBus1.创建bus.js文件 引入vue，创建一个vue实例，导出这个实例，代码如下: 123import Vue from 'vue';export default new Vue; 2.在组件中引入bus.js 1import Bus from '这里是你引入bus.js的路径' 3.通过vue实例方法$emit发送事件名称和需要传递的数据 1Bus.$emit('click', data) // 这个click是一个自定义的事件名称，data就是你要传递的数据。 传递间组件页面切换生命周期:从页面A到页面B跳转的时候：B组件 —— created —— beforeMount——A组件——beforeDestory——destoryed——B组件———mounted 所以：所以把A页面组件中的emit事件写在beforeDestory中去。因为这个时候，B页面组件已经被created了，也就是我们写的$on事件已经触发了 作者：Katherine的小世界链接：https://www.jianshu.com/p/fde85549e3b0来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 4.被传递数据的组件内通过vue实例方法$on监听到事件和接受到数据,通常挂载监听在vue生命周期created和mounted当中的一个。 123Bus.$on('click', target =&gt; { console.log(target)}) 5.在vue生命周期beforeDestroy或者destroyed中用vue实例的$off方法清除eventBus 123beforeDestroy(){ bus.$off('click')} 插槽slot 匿名插槽 单个插槽可以放置在组件的任意位置，一个组件中只能有一个该类插槽。 1&lt;slot&gt;&lt;/slot&gt; 具名插槽 具名插槽可以在一个组件中出现N次，出现在不同的位置。 父组件: 1&lt;children #{NAME}&gt;&lt;/children&gt; “v-slot:”缩写”#” 子组件: 1&lt;slot name=\"{NAME}\"&gt;&lt;/slot&gt; 滚动条scroll安装vue-gemini-scrollbar 1$ cnpm i vue-gemini-scrollbar --save 引入组件 123import GeminiScrollbar from 'vue-gemini-scrollbar';Vue.use(GeminiScrollbar); 使用 123&lt;GeminiScrollbar class=\"my-scroll-bar\"&gt; content...&lt;/GeminiScrollbar&gt; 123.my-scroll-bar{ height:200px;} 路由router跳转1&lt;a @click=\"gotoAddress('/')\"&gt;链接&lt;/a&gt; 12345methods: { gotoAddress(path) { this.$router.push(path); }} 或: 12345methods: { gotoAddress(pah) { this.$router.push({path: '{PATH}'}); }} 路由router传值a.vue 1234567&lt;script&gt;goToPage() { this.$router.push({name:'{PATHNAME}', params: {id: '{DATE}'}}) //或者: this.$router.push({name:'{PATHNAME}', query: {id: '{DATE}'}})}&lt;/script&gt; b.vue 123&lt;p&gt;{{ this.$route.params.id }}&lt;/p&gt;//或者:&lt;p&gt;{{ this.$route.query.id }}&lt;/p&gt;","link":"/2019/10/03/Vue-js-basics/"},{"title":"vue.js + express + socket.io 聊天室项目实战","text":"1. 新建vue-chat项目新建前端文件，后端文件，实现前后端分离 chat-client chat-server 2. git绑定remote branch2.1 创建gitignore文件将node_modules等配置文件放入gitignore文件中，实现本地工程文件与gitee绑定更加轻便。 2.2 初始化git仓库1$ git init 在vue-chat文件夹下，项目中生成了 .git 子目录，也就是生成了一个git仓库。 2.3 关联远程仓库1$ git remote add orgin {REPO_URL} 2.4 add files &amp;&amp; commit 将文件添加到git仓库（暂存区） 1$ git add . 保存 1$ git commit -sam \"{NAME}\" 第一次推送master分支的所有内容 1$ git push -u orgin master git回退指定版本号 12$ git log$ git reset --hard {COMMIT_LOG_NO} 3. socket.iosocket.io是基于Node.js和WebSocket协议的实时通信开源框架，它包括客户端的JavaScript和服务器端的Node.js。 双向通讯的协议WebSocket 安装 socket.io 1$ cnpm install --save soclet.io 4. 数据库新建与导入 mysql中新建数据库chatroom chatroom.sql中设置表格内容 12345678910111213141516DROP TABLE IF EXISTS `message`;CREATE TABLE `message` ( `id` int(11) NOT NULL AUTO_INCREMENT, `message_content` varchar(140) NOT NULL, `author` varchar(20) NOT NULL, `created_at` datetime DEFAULT current_timestamp(), PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `nickname` varchar(20) NOT NULL, `created_at` datetime DEFAULT current_timestamp(), PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 将文件chatroom.sql导入数据库chatroom中 1mysql -u -p chatroom &lt; chatroom.sql 5. 集成 socket.ioSocket.IO由两部分组成： 与Node.JS HTTP Server集成（或安装在其上）的服务器:socket.io 在浏览器端加载的客户端库:socket.io-client 5.1 socket.io模块实现基本通信server端: 1$ cnpm install --save socket.io 在App.js编辑: 123456var express = require('express');var app = express();var server = require('http').Server(app);var io = require('socket.io')(server);module.exports = {app: app, server: server, io: io}; client端: 1$ cnpm install --save socket.io-client 12345&lt;script&gt;import io from 'socket.io-client';const socket = io('http://localhost:3000');&lt;/script&gt; 5.2 client端向server端发射事件123&lt;script&gt;socket.emit('key', msg);&lt;/script&gt; 5.3 server端接收并发射事件12345io.on('connection', function(socket){ socket.on('key', function(msg){ io.emit('key', msg); });}); 6. server端数据存入数据库 安装sequelize 1$ cnpm install -S sequelize 安装mariadb 1$ cnpm install -S mariadb 通过sequelize创建连接 12345678910111213const Sequelize = require('sequelize');const sequelize = new Sequelize('mariadb://user:password@localhost:3306/databaseName');sequelize .authenticate() .then(() =&gt; { console.log('connection success') }) .catch((error) =&gt; { console.log('connection fail', error) });module.exports = sequelize; 新建model文件夹,新建表格文件message.js 在message.js中创建model形式映射数据库 12345678910111213141516171819202122const Sequelize = require('sequelize');const sequelize = require('../db'); const Model = Sequelize.Model;class Message extends Model {}//class User 继承 Model {}Message.init({ // User初始化 message_content: { type: Sequelize.STRING, }, author: { type: Sequelize.STRING }}, { sequelize, createdAt: false, updatedAt: false, tableName: 'message'});module.exports = Message; 在socket中连接成功情况下，向数据库传输数据: 1234567message.create({JSON}) .then((data) =&gt; { io.emit('key', data); }) .catch((error) =&gt; { io.emit('key', error); }); 7. socket自定义名称空间作为聊天房间client端 12345678910111213&lt;input v-model=\"roomSocket\"/&gt;&lt;script&gt;data() { return { roomSocket: null }}this.roomSocket = io('http://localhost:3000');this.roomSocket.emit('create', this.roomName);&lt;/script&gt; server端: 1234io.sockets.on('connection', (socket) =&gt; { socket.on('create', (room) =&gt; { socket.join(room); socket.emit('create_success', ''); 8. socket在房间路径下进行通信client端: 12345&lt;script&gt;this.roomSocket.emit('msg', obj);&lt;/script&gt; server端: 123socket.on('msg', data =&gt; { io.sockets.in(room).emit('broadcast_msg', obj);}) 登入获取用户名，存入vuex,发送信息时自动发送用户名、发送时间","link":"/2019/10/03/Vue-chat/"},{"title":"ES6 异步编程","text":"单线程单线程是Javascript语言最本质的特性之一，Javascript引擎在运行js代码的时候，同一个时间只能执行单个任务。 异步所谓的”异步”，就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 处理异步的方式1. 回调函数(callback)12345678function f1(callback){ setTimeout(function () { // f1的任务代码 callback(); }, 1000);}// 执行f1(f2) 注意: 回调并不一定就是异步。 同步回调: 12345678function A(callback){ console.log(\"I am A\"); callback(); //调用该函数}function B(){ console.log(\"I am B\");}A(B); 异步回调: 123456789var fs=require('fs');function getMime(callback){ fs.readFile('mime.json',function(err,data){ callback(data); })}getMime(function(result){ console.log(result.toString());}) 2. 事件监听监听函数有：on，bind，listen，addEventListener，observe 3. promiss对象promise有两种状态:1、等待（pending)2、完成（settled） promise会一直处于等待状态，直到它所包装的异步调用返回/超时/结束。 promise完成状态分成两类:1、解决（resolved）2、拒绝（rejected） async、awaitasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。async函数内部return语句返回的值，会成为then方法回调函数的参数。只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。","link":"/2019/10/24/ES6-异步编程/"},{"title":"Flask-SocketIO","text":"1. Flask-SocketIO介绍Flask是python的web框架,Flask-SocketIO使Flask应用程序可以访问客户端和服务器之间的低延迟双向通信。 2. 安装 pycharm新建flask项目 搭建虚拟环境 虚拟环境可以搭建独立的python运行环境, 使得单个项目的运行环境与其它项目互不影响。 安装虚拟环境 1$ python3 -m venv venv 激活虚拟环境 1$ source venv/bin/activate 退出虚拟环境 1$ deactivate 新建需求文件requirement.txt，放置记录所有依赖包及其精确的版本号，以便新环境部署 1$ touch requirement.txt requirement.txt: 1234567891011121314151617flaskflask-appconfigflask-bootstrapflask-navflask-sqlalchemyflask-loginflask-debugflask-wtfflask-adminflask-sqlacodegen #创建数据库模型flask-babelexflask-httpauthflask-sessionflask-cors #跨域配置pymysql #python3连接数据库mysql的库requestsflask-socketio #建立客户端与服务端双向通信 安装依赖包，安装requirement.txt依赖 1(venv) $ pip install -r requirement.txt flask 使用 创建flask实例对象 12from flask import Flaskapp = Flask(__name__) 构建实例对象从URL到python函数的映射关系 123@app.route('/')def index(): return 'hello word' 启动服务器 12if __name__ == '__main__': app.run() 端口号设置 PyCharm =&gt; edit Configurations =&gt; additional options =&gt; –port {NUMBER} flask-socketio使用 引入flask_socketio、flask_cors 12from flask_socketio import SocketIO, join_room, leave_room, send, emitfrom flask_cors import CORS 12345678app = Flask(__name__)cors = CORS(app) #允许跨域app.config['SECRET_KEY'] = 'secret!' #配置秘钥socketio = SocketIO(app, cors_allowed_origins='*') #配置允许跨域访问的源，*表示全部允许if __name__ == '__main__': socketio.run(app) 创建聊天房间 12345678910111213@socketio.on('join') #监听key值def on_join(data): username = data['username'] room = data['room'] join_room(room) #加入房间 send(username + ' has entered the room.', room=room)@socketio.on('leave')def on_leave(data): username = data['username'] room = data['room'] leave_room(room) #离开房间 send(username + ' has left the room.', room=room) 数据存入数据库 生成model.py文件 1$ flask-sqlacodegen 'mysql+pymysql://{USERNAME}:{PASSWORD}@localhost/{DATABASENAME}' --outfile \"model.py\" --flask 使用sqlacodegen声明数据模型: model.py: 12345678910111213141516171819from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class Message(db.Model): __tablename__ = 'message' id = db.Column(db.Integer, primary_key=True) message_content = db.Column(db.String(140), nullable=False) author = db.Column(db.String(20), nullable=False) created_at = db.Column(db.DateTime, server_default=db.FetchedValue())class User(db.Model): __tablename__ = 'user' id = db.Column(db.Integer, primary_key=True) nickname = db.Column(db.String(20), nullable=False) created_at = db.Column(db.DateTime, server_default=db.FetchedValue()) app.py中: 123from model import db, Messageapp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://user:password@localhost:3306/databaseName' #通过sqlacodegen将数据库与flask连接 socket.io监听数据并将数据存入数据库 1234567891011121314151617@socketio.on('msg')def on_msg(data): author = data['author'] message_content = data['message'] room = data['room'] print(author + ' in ' + room + ' says: ' + data['message']) message = Message( author=author, message_content=message_content ) db.session.add(message) #将message存入 db.session.commit() #保存 res = { 'author': author, 'message_content': message_content } emit('broadcast_msg', res, room=room)","link":"/2019/10/09/Flask-SocketIO/"},{"title":"Vue 进阶","text":"Vue mixinsmixins就是混入 一个混入对象可以包含任意组件选项。 同一个生命周期，混入对象会比组件的先执行。 1.创建一个test.js，用export暴露出mixins对象 1234567export const mixinsTest = { methods:{ hello(){ console.log(\"hello\"); } },} 2.在组件中引入这个mixins对象，通过mixins:[xxx]，使用mixins对象 123456789101112import {mixinsTest} from '{}'export default { data () { return { }; }, methods: { } //mixins的会先被调用,然后再执行组件的方法 mixins:[mixinsTest]} Vue router路由导航1. router-link :to=”…”1234567891011121314// 字符串&lt;router-link to=\"apple\"&gt; to apple&lt;/router-link&gt;// 对象&lt;router-link :to=\"{path:'apple'}\"&gt; to apple&lt;/router-link&gt;// 命名路由&lt;router-link :to=\"{name: 'applename'}\"&gt; to apple&lt;/router-link&gt;// 直接路由带查询参数query，地址栏变成 /apple?color=red&lt;router-link :to=\"{path: 'apple', query: {color: 'red' }}\"&gt; to apple&lt;/router-link&gt;// 命名路由带查询参数query，地址栏变成/apple?color=red&lt;router-link :to=\"{name: 'applename', query: {color: 'red' }}\"&gt; to apple&lt;/router-link&gt;// 直接路由带路由参数params，提供了path，则params不生效&lt;router-link :to=\"{path: 'apple', params: { color: 'red' }}\"&gt; to apple&lt;/router-link&gt;// 命名路由带路由参数params，地址栏是/apple/red&lt;router-link :to=\"{name: 'applename', params: { color: 'red' }}\"&gt; to apple&lt;/router-link&gt; 2. router.push(…)同样的规则也适用于router.push(…)方法 自定义指令directive按钮权限 btnPermissions1234567891011121314151617181920212223242526import Vue from 'vue'/**权限指令**/const has = Vue.directive('has', { bind: function (el, binding, vnode) { // 获取按钮权限 let btnPermissions = vnode.context.$route.meta.btnPermissions.split(\",\"); if (!Vue.prototype.$_has(btnPermissions)) { el.parentNode.removeChild(el); } }});// 权限检查方法Vue.prototype.$_has = function (value) { let isExist = false; let btnPermissionsStr = sessionStorage.getItem(\"btnPermissions\"); if (btnPermissionsStr == undefined || btnPermissionsStr == null) { return false; } if (value.indexOf(btnPermissionsStr) &gt; -1) { isExist = true; } return isExist;};export {has} 在main.js文件引入文件 1import has from './utils/btnPermissions.js'; 页面中按钮只需加v-has即可 1&lt;el-button @click='editClick' type=\"primary\" v-has&gt;编辑&lt;/el-button&gt; 自定义指令的钩子函数: 序号 钩子函数 生命周期 1 bind 刚绑定指令触发 2 inserted 元素插入父节点时候触发 3 update 每次元素更新时触发 4 componentUpdated 元素更新完成时触发 5 unbind 指令解绑这时候触发 Object.assignObject.keys Vuex持久化: vuex-persistedstate例如全局相关的，如登录状态、token、以及一些不常更新的状态等，我们更希望能够固化到本地，减少无用的接口访问 安装: 1npm install --save vuex-persistedstate store中index.js: 12345import persistedState from 'vuex-persistedstate'export default new Vuex.Store({ // ... plugins: [persistedState()]}) 自定义存储方式:vuex-persistedstate默认使用localStorage来固化数据 需要使用sessionStorage的情况: 123plugins: [ persistedState({ storage: window.sessionStorage })] 使用cookie的情况: 123456789101112131415import persistedState from 'vuex-persistedstate'import * as Cookies from 'js-cookie'export default new Vuex.Store({ // ... plugins: [ persistedState({ storage: { getItem: key =&gt; Cookies.get(key), setItem: (key, value) =&gt; Cookies.set(key, value, { expires: 7 }), removeItem: key =&gt; Cookies.remove(key) } }) ]}) Vue.nextTickVue事件循环：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 例子: 12345678910//改变数据vm.message = 'changed'//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新console.log(vm.$el.textContent) // 并不会得到'changed'//这样可以，nextTick里面的代码会在DOM更新后执行Vue.nextTick(function(){ console.log(vm.$el.textContent) //可以得到'changed'}) $route.matched1 一个数组，包含当前路由的所有嵌套路径片段的路由记录 2 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组 1234567watch: { $route: { handler(route) { console.log(this.$route.matched) } }}, pathToRegexp — url 的正则表达式安装 1npm install path-to-regexp --save 123456var pathToRegexp = require('path-to-regexp')var re = pathToRegexp('/foo/:bar')console.log(re);// /^\\/foo\\/((?:[^\\/]+?))(?:\\/(?=$))?$/i exec()匹配 url 地址与规则是否相符 parse()解析 url 字符串中的参数部分（:id） compile()快速填充 url 字符串的参数值 1234var pathToRegexp = require('path-to-regexp');var url = '/user/:id';console.log(pathToRegexp.parse(url)); 打印结果: 12345678[ '/user', { name: 'id', prefix: '/', delimiter: '/', optional: false, repeat: false, partial: false, pattern: '[^\\\\/]+?' } ] Vue手动刷新组件1.v-if 刷新页面 1234567891011121314151617&lt;div v-if=\"update\"&gt;&lt;/div&gt;&lt;script&gt; data() { return { update: true, } }, methods:{ reload() { this.update = false; this.$nextTick(() =&gt; { this.update = true }) } }&lt;/script&gt; 2.vm.$forceUpdate 强制刷新数据 123onShow() { this.$forceUpdate();}, 3.Vue router-view绑定key值刷新页面 VUE router-view key 属性解释123456789101112131415161718&lt;template&gt; &lt;section class=\"app-main\"&gt; &lt;transition name=\"fade-transform\" mode=\"out-in\"&gt; &lt;router-view :key=\"key\" /&gt; &lt;/transition&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'AppMain', computed: { key() { return this.$route.fullPath } }}&lt;/script&gt; key属性 /page/1 =&gt; /page/2 /page?id=1 =&gt; /page?id=2 不设置 组件复用 组件复用 属性值为 $route.path 组件不复用 组件复用 属性值为 $route.fullPath 组件不复用 组件不复用 组件复用钩子加载顺序:beforeRouteUpdate 组件不复用钩子加载顺序:beforeRouteUpdate =&gt; created =&gt; mounted $refs1this.$refs.form1 === this.$refs['form1'] //true render 函数render 函数 Functional Renderfunctional 函数化组件 functional: true true 可以使组件无状态和无实例，也就是没有 data 和 this 上下文。这样用 Render 函数返回虚拟节点可以更容易渲染 12345render: (h, ctx) =&gt; { return ( &lt;div&gt;&lt;/div&gt; )} 参数一: h，即 createElement，是 Render 函数的核心。 参数二: context, 来提供临时上下文。组件需要的 data、props、slots、children、parent 都是通过这个上下文来传递的，比如 this.level 要改写为 context.props.level，this.$slots.default 改写为 context.children。 $options 获取自定义属性provide / inject允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 父组件： 123456provide() { return { map_nodeObj: { map_node: this.obj } // 提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 }}, 子组件: 123456789 inject: { map_nodeObj: { default: () =&gt; { return {map_node: '0'} } } }, 使用： this.map_nodeObj.map_node 运行顺序： 1234dataprovidecreated // 在这个阶段$el还未生成，在这先处理privide的逻辑，子孙组件才可以取到inject的值mounted mixin定义组件公用的变量、方法 特点： 方法和参数在各组件中不共享 如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的 值为函数的选项，如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用 混入对象中的方法 mixin.js: 123456789101112export default { data() { return{ num: 1, } }, methods: { hello() { console.log('aaa') } }} 需引入mixin的组件： 12345678910111213import mixin from ''export default { mixins: [mixin] data() { return{ } }, created() { this.hello() console.log(this.num) },}","link":"/2019/10/27/vue-进阶/"},{"title":"js 事件处理方法","text":"事件委托访问dom的次数越多，就会增加浏览器重绘与重排的次数，页面性能优化的主要思想之一就是减少与dom的交互次数，提高性能。 事件委托是利用事件的冒泡原理来实现的，委托目标节点的父级代为执行事件。 自定义属性“data-“ HTML5规定为元素添加非标准的属性要添加前缀data- 添加自定义属性之后，可以通过元素的dataset属性来访问自定义的值。 在添加或读取属性的时候需要去掉前缀data- 如果属性名称中还包含连字符(-)，需要转成驼峰命名方式，但如果在CSS中使用选择器，我们需要使用连字符格式 1234567891011&lt;ul @click=\"func($event)\" v-for=\"(item, index) in items\" :key=\"index\"&gt; &lt;li :data-id=\"index\"&gt;{{ item }}&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; methods: { func(event) { console.log(event.target.dataset.id); } }&lt;/script&gt; target 事件属性语法: 1event.target 事件属性可返回事件的目标节点（触发该事件的节点） nodeName &amp;&amp; tagNameDOM里面一共有12种节点类型，常见的3种节点类型: 元素节点 (标签) 属性节点 (id, name, class) 文本节点 (文本内容) tagName: 只能用在元素节点上nodeName: 可以用在任何节点上，可以说nodeName涵盖了tagName $event访问原始的 DOM 事件,可以用特殊变量 $event 把它传入方法: 123456&lt;button @click=\"func($event)\"&gt;按钮&lt;/button&gt;methods: { func(event) { }} vue点击事件的节点信息获取与操作： 123456789101112131415161718192021222324252627282930313233343536373839404142methods: { f_click: function(event){ // 当前点击的元素 event.target; // 绑定事件的元素 event.currentTarget; // （target与currentTarget的区别主要体现在使用事件委托时，发生事件委托时，点击的元素与绑定事件的元素非同一元素，反之不发生事件委托时，两者相同，是同一元素） // 获得绑定事件元素的前一个节点信息（包含元素节点、属性节点、文本节点、注释节点） event.currentTarget.previousSibling; // 获得绑定事件元素的前一个元素节点（只包含元素节点，只有html内容） event.currentTarget.previousElementSibling; // 下一个元素信息获取使用 nextSibling、nextElementSibling // 获得绑定事件元素的父节点信息 event.currentTarget.parentNode; // 获得绑定事件元素的父级元素 event.currentTarget.parentElement; // 获得绑定事件元素的第一个子节点信息 event.currentTarget.firstChild; // 获得绑定事件元素的第一个子元素 event.currentTarget.firstElementChild; // 获得绑定事件元素中id为ceshi的元素集合 event.currentTarget.getElementById(\"ceshi\"); // 获得绑定事件元素中class为ceshi的元素集合 event.currentTarget.getElementsByClassName(\"ceshi\"); // 获得绑定事件元素的的内容（类似jquery的text()） event.currentTarget.textContent; // 获得绑定事件元素的的内容（类似jquery的html()） event.currentTarget.innerHTML; // 获得绑定事件元素的ceshi属性（类似jquery的attr('ceshi')） event.currentTarget.getAttributeNode(\"ceshi\"); // 点击删除当前元素 event.currentTarget.parentElement.removeChild(event.currentTarget); // 点击删除当前元素的父级元素 event.currentTarget.parentElement.parentElement.removeChild(event.currentTarget.parentElement); }}","link":"/2019/10/27/js-事件处理方法/"},{"title":"web.py","text":"介绍web.py是一款轻量级的python web开发框架，简单、高效，适合作为python web开发的入门框架。 安装1$ pip install web.py==0.40 web.py运行12345678910111213import web #导入web.pyurls = ( '/', 'index' #url映射)class index: #url处理的类 def GET(self): return \"Hello, world!\"if __name__ == \"__main__\": app = web.application(urls, globals()) app.run() #启用web应用 模板给模板新建一个目录（命名为 templates），在该目录下新建一个以 .html 结尾的文件: 1&lt;em&gt;Hello&lt;/em&gt;, world! 调用模板: 12345render = web.template.render('templates/')class index: def GET(self): return render.abc() #这里的abc是对应于templates下的abc.html的文件名。 数据库操作安装pymysql 1$ pip install pymysql 引入pymysql 1import pymysql 连接数据库 1db = web.database(dbn='mysql', user='username', pw='password', db='dbname') 导入数据库数据 123def GET(self): todos = db.select('todo') #todo为数据库表格名 return render.index(todos) 然后把URL列表改回来，只保留 /: 1'/', 'index', 编辑abc.html,遍历数据显示在客户端 12345$def with (todos)&lt;ul&gt;$for todo in todos: &lt;li id=\"t$todo.id\"&gt;$todo.title&lt;/li&gt;&lt;/ul&gt; POST请求客户端通过input提交数据: 123&lt;form method=\"post\" action=\"add\"&gt;&lt;p&gt;&lt;input type=\"text\" name=\"title\" /&gt; &lt;input type=\"submit\" value=\"Add\" /&gt;&lt;/p&gt;&lt;/form&gt; 通过POST请求，向数据库传入数据，并在服务端刷新显示: 12345678'/', 'index','/add', 'add'class add: def POST(self): i = web.input() #web.input 可以访问用户通过form提交的任何数据 n = db.insert('todo', title=i.title) #数据库插入数据 web.seeother('/') #网页跳转与重定向:POST完成处理后，浏览器会对新网址发出GET请求，完成新跳转。","link":"/2019/10/18/web-py/"},{"title":"ubunto-nginx","text":"nginx介绍Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器 两大主流web server对比 nginx apache 轻量级 模块较多，较全面 处理请求是异步非阻塞 阻塞型 高度模块化的设计 少bug ubunto环境下nginx运行命令安装： 1$ sudo apt install nginx 查看安装版本 1$ nginx -v 启动： 1$ sudo service nginx start 停止： 1$ sudo service nginx stop 重读配置文件： 1$ sudo service nginx reload 重启： 1$ sudo service nginx restart 查看进程： 1$ ps aux|grep nginx 操作手册： 1$ man nginx 状态详解： 1$ sudo service nginx status nginx安装目录：/etc/nginx 主要配置文件夹： nginx.conf sites-available: 有所有的（N个站点）配置，包括临时不启用的站点 sites-enabled: 当前启用的站点 nginx三大应用反向代理12345678910111213141516# 配置一个代理即 tomcat 服务器upstream tomcatServer { server 192.168.75.145:9090;}# 配置一个虚拟主机server { listen 80; server_name admin.service.itoken.funtl.com; location / { # 域名 admin.service.itoken.funtl.com 的请求全部转发到 tomcat_server 即 tomcat 服务上 proxy_pass http://tomcatServer; # 欢迎页面，按照从左到右的顺序查找页面 index index.jsp index.html index.htm; }} 负载均衡 weight 1234upstream server_pool{ server 192.168.0.1 weight=1 server 192.168.0.2 weight=2} ip_hash 每个访客固定访问一个后端服务器 12345upstream server_pool{ ip_hash server 192.168.0.1:80 server 192.168.0.2:80} fair 后端服务器响应时间短优先分配 12345upstream server_pool{ server 192.168.0.1:80 server 192.168.0.2:80 fair} 动静分离123456789101112131415location = / { proxy_pass http://sunpy.com; #root html; #index index.html index.htm; include proxy_nginx.conf;}location ~* \\.(gif|jpg|jpeg|png|css|js|ico|svg)$ { root /nginx/sunpy_res/static/;}error_page 500 502 503 504 /50x.html;location = /50x.html { root html;}","link":"/2019/11/30/nginx/"},{"title":"ubunto","text":"linux || ubunto只检查，不更新: 1sudo apt update 更新已安装的软件包: 1sudo apt upgrade 软件包名 补充：文件权限设置: 1$ chmod 777 file 说明：第1个7设置用户的权限，第2个7设置组的权限，第3个7设置其他所有者的权限。 读-r-4 写-w-2 执行-x-1 0: 没有权限4: 读取权限5: 4+1 | 读取+执行6: 4+2 | 读取+写入7: 4+2+1 | 读取+写入+执行 查看文件尾： 12345678910111213$ tail [参数] [文件]``` 查看文件头：```bash$ head [参数] [文件]``` 访问链接：``` bash$ sudo install curl 访问链接： 1$ ln -s [源文件或目录] [目标文件或目录]","link":"/2019/12/02/ubunto/"},{"title":"Vue 插件","text":"Vue-countTo 数字滚动组件安装 1npm install vue-count-to 1234567891011121314151617&lt;template&gt; &lt;countTo :startVal='startVal' :endVal='endVal' :duration='3000'&gt;&lt;/countTo&gt;&lt;/template&gt;&lt;script&gt; import countTo from 'vue-count-to'; export default { components: { countTo }, data () { return { startVal: 0, endVal: 2017 } } }&lt;/script&gt; Vue I18n 语言环境插件1$ npm install vue-i18n 1234import Vue from 'vue'import VueI18n from 'vue-i18n'Vue.use(VueI18n)","link":"/2019/10/29/Vue-插件/"}],"tags":[{"name":"小程序 身份证识别 face++","slug":"小程序-身份证识别-face","link":"/tags/小程序-身份证识别-face/"}],"categories":[]}